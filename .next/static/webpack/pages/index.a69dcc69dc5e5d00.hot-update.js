"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./lib/firestore.ts":
/*!**************************!*\
  !*** ./lib/firestore.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAllTeams: function() { return /* binding */ getAllTeams; },\n/* harmony export */   subscribeToTeams: function() { return /* binding */ subscribeToTeams; },\n/* harmony export */   updatePhysicalScore: function() { return /* binding */ updatePhysicalScore; }\n/* harmony export */ });\n/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/database */ \"./node_modules/firebase/database/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"./lib/firebase.ts\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/auth */ \"./node_modules/firebase/auth/dist/esm/index.esm.js\");\n// Firebase Realtime Database operations for AR Treasure Hunt Volunteer Page\n\n\n\n/**\n * Ensure user is authenticated before database operations\n */ async function ensureAuth() {\n    if (!_firebase__WEBPACK_IMPORTED_MODULE_1__.auth.currentUser) {\n        try {\n            await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.signInAnonymously)(_firebase__WEBPACK_IMPORTED_MODULE_1__.auth);\n        } catch (error) {\n            console.error(\"Failed to authenticate anonymously:\", error);\n            throw new Error(\"Authentication required\");\n        }\n    }\n}\n/**\n * Get session data for a team\n */ async function getTeamSession(uid) {\n    try {\n        const sessionRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"\".concat(uid, \"/Session\"));\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(sessionRef);\n        if (snapshot.exists()) {\n            return snapshot.val();\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting team session:\", error);\n        return null;\n    }\n}\n/**\n * Get all teams for the volunteer interface\n */ async function getAllTeams() {\n    try {\n        await ensureAuth();\n        const rootRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(rootRef);\n        if (!snapshot.exists()) {\n            return [];\n        }\n        const allData = snapshot.val();\n        const teamsArray = [];\n        console.log(\"Raw Firebase data:\", allData);\n        // Filter only valid team nodes (those with teamName property)\n        for(const uid in allData){\n            if (allData[uid] && typeof allData[uid] === \"object\" && allData[uid].teamName) {\n                const rawTeamData = allData[uid];\n                console.log(\"Processing team \".concat(uid, \":\"), rawTeamData);\n                // Create team data without the Session node first\n                const teamData = {\n                    ...rawTeamData\n                };\n                teamData.uid = uid; // Ensure UID is set\n                // Ensure physicalScore and comment are included\n                teamData.physicalScore = teamData.physicalScore || 0;\n                teamData.physicalScoreComment = teamData.physicalScoreComment || \"\";\n                // Check if Session data exists as a nested object\n                if (rawTeamData.Session && typeof rawTeamData.Session === \"object\") {\n                    console.log(\"Found session data for team \".concat(uid, \":\"), rawTeamData.Session);\n                    teamData.session = rawTeamData.Session;\n                    // Remove the Session from the main team data to avoid duplication\n                    delete teamData.Session;\n                } else {\n                    console.log(\"No session data found for team \".concat(uid, \", checking for alternative session data...\"));\n                    console.log(\"Available keys in team data:\", Object.keys(rawTeamData));\n                    // Default session data for teams that haven't started\n                    teamData.session = {\n                        currentClue: 0,\n                        cluesSolved: 0,\n                        totalClues: 0,\n                        status: \"not_started\"\n                    };\n                }\n                console.log(\"Final processed team data for \".concat(uid, \":\"), teamData);\n                teamsArray.push(teamData);\n            } else {\n                console.log(\"Skipping invalid team data for \".concat(uid, \":\"), allData[uid]);\n            }\n        }\n        // Sort by team number (ascending)\n        teamsArray.sort((a, b)=>a.teamNumber - b.teamNumber);\n        return teamsArray;\n    } catch (error) {\n        console.error(\"Error getting teams:\", error);\n        return [];\n    }\n}\n/**\n * Update a team's physical score with comment\n */ async function updatePhysicalScore(uid, physicalScore, comment) {\n    try {\n        await ensureAuth();\n        const teamRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db, uid);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(teamRef);\n        if (!snapshot.exists()) {\n            throw new Error(\"Team not found with the provided UID\");\n        }\n        // Update the physical score and comment\n        const updateData = {\n            physicalScore: physicalScore\n        };\n        if (comment !== undefined) {\n            updateData.physicalScoreComment = comment;\n        }\n        await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(teamRef, updateData);\n        return true;\n    } catch (error) {\n        console.error(\"Error updating physical score:\", error);\n        throw error;\n    }\n}\n/**\n * Set up real-time listener for team updates\n */ function subscribeToTeams(callback) {\n    try {\n        const rootRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_1__.db);\n        console.log(\"Setting up Realtime Database listener for teams...\");\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(rootRef, (snapshot)=>{\n            console.log(\"Realtime Database snapshot received\");\n            if (!snapshot.exists()) {\n                console.log(\"No data found\");\n                callback([]);\n                return;\n            }\n            const allData = snapshot.val();\n            const teamsArray = [];\n            // Filter only valid team nodes (those with teamName property)\n            for(const uid in allData){\n                if (allData[uid] && typeof allData[uid] === \"object\" && allData[uid].teamName) {\n                    const rawTeamData = allData[uid];\n                    console.log(\"Real-time: Processing team \".concat(uid, \":\"), rawTeamData);\n                    // Create team data without the Session node first\n                    const teamData = {\n                        ...rawTeamData\n                    };\n                    teamData.uid = uid; // Ensure UID is set\n                    // Ensure physicalScore and comment are included\n                    teamData.physicalScore = teamData.physicalScore || 0;\n                    teamData.physicalScoreComment = teamData.physicalScoreComment || \"\";\n                    // Handle session data from the snapshot\n                    if (rawTeamData.Session && typeof rawTeamData.Session === \"object\") {\n                        console.log(\"Real-time: Found session data for team \".concat(uid, \":\"), rawTeamData.Session);\n                        teamData.session = rawTeamData.Session;\n                        // Remove the Session from the main team data to avoid duplication\n                        delete teamData.Session;\n                    } else {\n                        console.log(\"Real-time: No session data found for team \".concat(uid));\n                        console.log(\"Real-time: Available keys in team data:\", Object.keys(rawTeamData));\n                        // Default session data for teams that haven't started\n                        teamData.session = {\n                            currentClue: 0,\n                            cluesSolved: 0,\n                            totalClues: 0,\n                            status: \"not_started\"\n                        };\n                    }\n                    console.log(\"Real-time: Final processed team data for \".concat(uid, \":\"), teamData);\n                    teamsArray.push(teamData);\n                } else {\n                    console.log(\"Real-time: Skipping invalid team data for \".concat(uid, \":\"), allData[uid]);\n                }\n            }\n            console.log(\"Teams data:\", teamsArray);\n            // Sort by team number (ascending)\n            teamsArray.sort((a, b)=>a.teamNumber - b.teamNumber);\n            callback(teamsArray);\n        }, (error)=>{\n            console.error(\"Realtime Database listener error:\", error);\n            callback([]);\n        });\n        // Return unsubscribe function\n        return ()=>{\n            console.log(\"Unsubscribing from Realtime Database listener\");\n            (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.off)(rootRef, \"value\", unsubscribe);\n        };\n    } catch (error) {\n        console.error(\"Error setting up Realtime Database listener:\", error);\n        return ()=>{};\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFDaEVKLFdBQVdlLElBQUksQ0FBQ1g7Z0JBQ2xCLE9BQU87b0JBQ0xmLFFBQVFZLEdBQUcsQ0FBQyw2Q0FBaUQsT0FBSlQsS0FBSSxNQUFJTyxPQUFPLENBQUNQLElBQUk7Z0JBQy9FO1lBQ0Y7WUFFQUgsUUFBUVksR0FBRyxDQUFDLGVBQWVEO1lBRTNCLGtDQUFrQztZQUNsQ0EsV0FBV2dCLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFRSxVQUFVLEdBQUdELEVBQUVDLFVBQVU7WUFFckRPLFNBQVMxQjtRQUNYLEdBQ0EsQ0FBQ1o7WUFDQ0MsUUFBUUQsS0FBSyxDQUFDLHFDQUFxQ0E7WUFDbkRzQyxTQUFTLEVBQUU7UUFDYjtRQUdGLDhCQUE4QjtRQUM5QixPQUFPO1lBQ0xyQyxRQUFRWSxHQUFHLENBQUM7WUFDWm5CLHNEQUFHQSxDQUFDZ0IsU0FBUyxTQUFTNkI7UUFDeEI7SUFDRixFQUFFLE9BQU92QyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxnREFBZ0RBO1FBQzlELE9BQU8sS0FBTztJQUNoQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9maXJlc3RvcmUudHM/YjQ2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaXJlYmFzZSBSZWFsdGltZSBEYXRhYmFzZSBvcGVyYXRpb25zIGZvciBBUiBUcmVhc3VyZSBIdW50IFZvbHVudGVlciBQYWdlXG5cbmltcG9ydCB7XG4gIHJlZixcbiAgZ2V0LFxuICB1cGRhdGUsXG4gIG9uVmFsdWUsXG4gIG9mZlxufSBmcm9tICdmaXJlYmFzZS9kYXRhYmFzZSc7XG5pbXBvcnQgeyBkYiwgYXV0aCB9IGZyb20gJy4vZmlyZWJhc2UnO1xuaW1wb3J0IHsgc2lnbkluQW5vbnltb3VzbHkgfSBmcm9tICdmaXJlYmFzZS9hdXRoJztcblxuLy8gRGVmaW5lIHRoZSBTZXNzaW9uIGludGVyZmFjZSBmb3IgdGVhbSBwcm9ncmVzc1xuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uIHtcbiAgLy8gQWN0dWFsIGZpZWxkIG5hbWVzIGZyb20geW91ciBGaXJlYmFzZSBzdHJ1Y3R1cmVcbiAgY2x1ZXNDb21wbGV0ZWQ/OiBudW1iZXI7XG4gIGN1cnJlbnRDbHVlTnVtYmVyPzogbnVtYmVyO1xuICBzdGFydGVkPzogYm9vbGVhbjtcbiAgXG4gIC8vIExlZ2FjeS9hbHRlcm5hdGl2ZSBmaWVsZCBuYW1lcyBmb3IgY29tcGF0aWJpbGl0eVxuICBjdXJyZW50Q2x1ZT86IG51bWJlcjtcbiAgY2x1ZXNTb2x2ZWQ/OiBudW1iZXI7XG4gIHRvdGFsQ2x1ZXM/OiBudW1iZXI7XG4gIHRpbWVTdGFydGVkPzogbnVtYmVyO1xuICBsYXN0QWN0aXZpdHk/OiBudW1iZXI7XG4gIHN0YXR1cz86IHN0cmluZztcbiAgcHJvZ3Jlc3NNZXRyaWNzPzoge1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgfTtcbiAgY3VycmVudExldmVsPzogbnVtYmVyO1xuICBnYW1lU3RhcnRlZD86IGJvb2xlYW47XG4gIGlzQWN0aXZlPzogYm9vbGVhbjtcbiAgbGFzdENsdWVUaW1lPzogbnVtYmVyO1xuICBba2V5OiBzdHJpbmddOiBhbnk7IC8vIEFsbG93IGZvciBhbnkgYWRkaXRpb25hbCBmaWVsZHNcbn1cblxuLy8gRGVmaW5lIHRoZSBUZWFtIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBUZWFtIHtcbiAgdWlkOiBzdHJpbmc7XG4gIHRlYW1OdW1iZXI6IG51bWJlcjtcbiAgdGVhbU5hbWU6IHN0cmluZztcbiAgcGxheWVyMTogc3RyaW5nO1xuICBwbGF5ZXIyOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHBob25lTnVtYmVyOiBzdHJpbmc7XG4gIHNjb3JlOiBudW1iZXI7XG4gIHBoeXNpY2FsU2NvcmU/OiBudW1iZXI7XG4gIHBoeXNpY2FsU2NvcmVDb21tZW50Pzogc3RyaW5nOyAvLyBDb21tZW50IGZpZWxkIGZvciBwaHlzaWNhbCBzY29yZVxuICBjcmVhdGVkQXQ6IG51bWJlcjtcbiAgc2Vzc2lvbj86IFNlc3Npb247IC8vIFNlc3Npb24gZGF0YSBmb3IgcHJvZ3Jlc3MgdHJhY2tpbmdcbn1cblxuLyoqXG4gKiBFbnN1cmUgdXNlciBpcyBhdXRoZW50aWNhdGVkIGJlZm9yZSBkYXRhYmFzZSBvcGVyYXRpb25zXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZUF1dGgoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmICghYXV0aC5jdXJyZW50VXNlcikge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzaWduSW5Bbm9ueW1vdXNseShhdXRoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZSBhbm9ueW1vdXNseTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHNlc3Npb24gZGF0YSBmb3IgYSB0ZWFtXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFRlYW1TZXNzaW9uKHVpZDogc3RyaW5nKTogUHJvbWlzZTxTZXNzaW9uIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHNlc3Npb25SZWYgPSByZWYoZGIsIGAke3VpZH0vU2Vzc2lvbmApO1xuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0KHNlc3Npb25SZWYpO1xuICAgIFxuICAgIGlmIChzbmFwc2hvdC5leGlzdHMoKSkge1xuICAgICAgcmV0dXJuIHNuYXBzaG90LnZhbCgpIGFzIFNlc3Npb247XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbSBzZXNzaW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBhbGwgdGVhbXMgZm9yIHRoZSB2b2x1bnRlZXIgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxUZWFtcygpOiBQcm9taXNlPFRlYW1bXT4ge1xuICB0cnkge1xuICAgIGF3YWl0IGVuc3VyZUF1dGgoKTtcbiAgICBjb25zdCByb290UmVmID0gcmVmKGRiKTtcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldChyb290UmVmKTtcbiAgICBcbiAgICBpZiAoIXNuYXBzaG90LmV4aXN0cygpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYWxsRGF0YSA9IHNuYXBzaG90LnZhbCgpO1xuICAgIGNvbnN0IHRlYW1zQXJyYXk6IFRlYW1bXSA9IFtdO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdSYXcgRmlyZWJhc2UgZGF0YTonLCBhbGxEYXRhKTtcbiAgICBcbiAgICAvLyBGaWx0ZXIgb25seSB2YWxpZCB0ZWFtIG5vZGVzICh0aG9zZSB3aXRoIHRlYW1OYW1lIHByb3BlcnR5KVxuICAgIGZvciAoY29uc3QgdWlkIGluIGFsbERhdGEpIHtcbiAgICAgIGlmIChhbGxEYXRhW3VpZF0gJiYgdHlwZW9mIGFsbERhdGFbdWlkXSA9PT0gJ29iamVjdCcgJiYgYWxsRGF0YVt1aWRdLnRlYW1OYW1lKSB7XG4gICAgICAgIGNvbnN0IHJhd1RlYW1EYXRhID0gYWxsRGF0YVt1aWRdO1xuICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyB0ZWFtICR7dWlkfTpgLCByYXdUZWFtRGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgdGVhbSBkYXRhIHdpdGhvdXQgdGhlIFNlc3Npb24gbm9kZSBmaXJzdFxuICAgICAgICBjb25zdCB0ZWFtRGF0YSA9IHsgLi4ucmF3VGVhbURhdGEgfSBhcyBUZWFtO1xuICAgICAgICB0ZWFtRGF0YS51aWQgPSB1aWQ7IC8vIEVuc3VyZSBVSUQgaXMgc2V0XG4gICAgICAgIFxuICAgICAgICAvLyBFbnN1cmUgcGh5c2ljYWxTY29yZSBhbmQgY29tbWVudCBhcmUgaW5jbHVkZWRcbiAgICAgICAgdGVhbURhdGEucGh5c2ljYWxTY29yZSA9IHRlYW1EYXRhLnBoeXNpY2FsU2NvcmUgfHwgMDtcbiAgICAgICAgdGVhbURhdGEucGh5c2ljYWxTY29yZUNvbW1lbnQgPSB0ZWFtRGF0YS5waHlzaWNhbFNjb3JlQ29tbWVudCB8fCAnJztcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIFNlc3Npb24gZGF0YSBleGlzdHMgYXMgYSBuZXN0ZWQgb2JqZWN0XG4gICAgICAgIGlmIChyYXdUZWFtRGF0YS5TZXNzaW9uICYmIHR5cGVvZiByYXdUZWFtRGF0YS5TZXNzaW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBzZXNzaW9uIGRhdGEgZm9yIHRlYW0gJHt1aWR9OmAsIHJhd1RlYW1EYXRhLlNlc3Npb24pO1xuICAgICAgICAgIHRlYW1EYXRhLnNlc3Npb24gPSByYXdUZWFtRGF0YS5TZXNzaW9uIGFzIFNlc3Npb247XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBTZXNzaW9uIGZyb20gdGhlIG1haW4gdGVhbSBkYXRhIHRvIGF2b2lkIGR1cGxpY2F0aW9uXG4gICAgICAgICAgZGVsZXRlICh0ZWFtRGF0YSBhcyBhbnkpLlNlc3Npb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYE5vIHNlc3Npb24gZGF0YSBmb3VuZCBmb3IgdGVhbSAke3VpZH0sIGNoZWNraW5nIGZvciBhbHRlcm5hdGl2ZSBzZXNzaW9uIGRhdGEuLi5gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQXZhaWxhYmxlIGtleXMgaW4gdGVhbSBkYXRhOmAsIE9iamVjdC5rZXlzKHJhd1RlYW1EYXRhKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRGVmYXVsdCBzZXNzaW9uIGRhdGEgZm9yIHRlYW1zIHRoYXQgaGF2ZW4ndCBzdGFydGVkXG4gICAgICAgICAgdGVhbURhdGEuc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRDbHVlOiAwLFxuICAgICAgICAgICAgY2x1ZXNTb2x2ZWQ6IDAsXG4gICAgICAgICAgICB0b3RhbENsdWVzOiAwLFxuICAgICAgICAgICAgc3RhdHVzOiAnbm90X3N0YXJ0ZWQnXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYEZpbmFsIHByb2Nlc3NlZCB0ZWFtIGRhdGEgZm9yICR7dWlkfTpgLCB0ZWFtRGF0YSk7XG4gICAgICAgIHRlYW1zQXJyYXkucHVzaCh0ZWFtRGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgU2tpcHBpbmcgaW52YWxpZCB0ZWFtIGRhdGEgZm9yICR7dWlkfTpgLCBhbGxEYXRhW3VpZF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBTb3J0IGJ5IHRlYW0gbnVtYmVyIChhc2NlbmRpbmcpXG4gICAgdGVhbXNBcnJheS5zb3J0KChhLCBiKSA9PiBhLnRlYW1OdW1iZXIgLSBiLnRlYW1OdW1iZXIpO1xuICAgIFxuICAgIHJldHVybiB0ZWFtc0FycmF5O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdGVhbXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhIHRlYW0ncyBwaHlzaWNhbCBzY29yZSB3aXRoIGNvbW1lbnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBoeXNpY2FsU2NvcmUodWlkOiBzdHJpbmcsIHBoeXNpY2FsU2NvcmU6IG51bWJlciwgY29tbWVudD86IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGF3YWl0IGVuc3VyZUF1dGgoKTtcbiAgICBjb25zdCB0ZWFtUmVmID0gcmVmKGRiLCB1aWQpO1xuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0KHRlYW1SZWYpO1xuICAgIFxuICAgIGlmICghc25hcHNob3QuZXhpc3RzKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVhbSBub3QgZm91bmQgd2l0aCB0aGUgcHJvdmlkZWQgVUlEJyk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBwaHlzaWNhbCBzY29yZSBhbmQgY29tbWVudFxuICAgIGNvbnN0IHVwZGF0ZURhdGE6IGFueSA9IHtcbiAgICAgIHBoeXNpY2FsU2NvcmU6IHBoeXNpY2FsU2NvcmVcbiAgICB9O1xuICAgIFxuICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVwZGF0ZURhdGEucGh5c2ljYWxTY29yZUNvbW1lbnQgPSBjb21tZW50O1xuICAgIH1cblxuICAgIGF3YWl0IHVwZGF0ZSh0ZWFtUmVmLCB1cGRhdGVEYXRhKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHBoeXNpY2FsIHNjb3JlOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIFNldCB1cCByZWFsLXRpbWUgbGlzdGVuZXIgZm9yIHRlYW0gdXBkYXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlVG9UZWFtcyhjYWxsYmFjazogKHRlYW1zOiBUZWFtW10pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByb290UmVmID0gcmVmKGRiKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnU2V0dGluZyB1cCBSZWFsdGltZSBEYXRhYmFzZSBsaXN0ZW5lciBmb3IgdGVhbXMuLi4nKTtcbiAgICBcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IG9uVmFsdWUocm9vdFJlZiwgXG4gICAgICAoc25hcHNob3QpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlYWx0aW1lIERhdGFiYXNlIHNuYXBzaG90IHJlY2VpdmVkJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXNuYXBzaG90LmV4aXN0cygpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ05vIGRhdGEgZm91bmQnKTtcbiAgICAgICAgICBjYWxsYmFjayhbXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWxsRGF0YSA9IHNuYXBzaG90LnZhbCgpO1xuICAgICAgICBjb25zdCB0ZWFtc0FycmF5OiBUZWFtW10gPSBbXTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZpbHRlciBvbmx5IHZhbGlkIHRlYW0gbm9kZXMgKHRob3NlIHdpdGggdGVhbU5hbWUgcHJvcGVydHkpXG4gICAgICAgIGZvciAoY29uc3QgdWlkIGluIGFsbERhdGEpIHtcbiAgICAgICAgICBpZiAoYWxsRGF0YVt1aWRdICYmIHR5cGVvZiBhbGxEYXRhW3VpZF0gPT09ICdvYmplY3QnICYmIGFsbERhdGFbdWlkXS50ZWFtTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgcmF3VGVhbURhdGEgPSBhbGxEYXRhW3VpZF07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVhbC10aW1lOiBQcm9jZXNzaW5nIHRlYW0gJHt1aWR9OmAsIHJhd1RlYW1EYXRhKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRlYW0gZGF0YSB3aXRob3V0IHRoZSBTZXNzaW9uIG5vZGUgZmlyc3RcbiAgICAgICAgICAgIGNvbnN0IHRlYW1EYXRhID0geyAuLi5yYXdUZWFtRGF0YSB9IGFzIFRlYW07XG4gICAgICAgICAgICB0ZWFtRGF0YS51aWQgPSB1aWQ7IC8vIEVuc3VyZSBVSUQgaXMgc2V0XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEVuc3VyZSBwaHlzaWNhbFNjb3JlIGFuZCBjb21tZW50IGFyZSBpbmNsdWRlZFxuICAgICAgICAgICAgdGVhbURhdGEucGh5c2ljYWxTY29yZSA9IHRlYW1EYXRhLnBoeXNpY2FsU2NvcmUgfHwgMDtcbiAgICAgICAgICAgIHRlYW1EYXRhLnBoeXNpY2FsU2NvcmVDb21tZW50ID0gdGVhbURhdGEucGh5c2ljYWxTY29yZUNvbW1lbnQgfHwgJyc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzZXNzaW9uIGRhdGEgZnJvbSB0aGUgc25hcHNob3RcbiAgICAgICAgICAgIGlmIChyYXdUZWFtRGF0YS5TZXNzaW9uICYmIHR5cGVvZiByYXdUZWFtRGF0YS5TZXNzaW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVhbC10aW1lOiBGb3VuZCBzZXNzaW9uIGRhdGEgZm9yIHRlYW0gJHt1aWR9OmAsIHJhd1RlYW1EYXRhLlNlc3Npb24pO1xuICAgICAgICAgICAgICB0ZWFtRGF0YS5zZXNzaW9uID0gcmF3VGVhbURhdGEuU2Vzc2lvbiBhcyBTZXNzaW9uO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBTZXNzaW9uIGZyb20gdGhlIG1haW4gdGVhbSBkYXRhIHRvIGF2b2lkIGR1cGxpY2F0aW9uXG4gICAgICAgICAgICAgIGRlbGV0ZSAodGVhbURhdGEgYXMgYW55KS5TZXNzaW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlYWwtdGltZTogTm8gc2Vzc2lvbiBkYXRhIGZvdW5kIGZvciB0ZWFtICR7dWlkfWApO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVhbC10aW1lOiBBdmFpbGFibGUga2V5cyBpbiB0ZWFtIGRhdGE6YCwgT2JqZWN0LmtleXMocmF3VGVhbURhdGEpKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIERlZmF1bHQgc2Vzc2lvbiBkYXRhIGZvciB0ZWFtcyB0aGF0IGhhdmVuJ3Qgc3RhcnRlZFxuICAgICAgICAgICAgICB0ZWFtRGF0YS5zZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDbHVlOiAwLFxuICAgICAgICAgICAgICAgIGNsdWVzU29sdmVkOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsQ2x1ZXM6IDAsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnbm90X3N0YXJ0ZWQnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWFsLXRpbWU6IEZpbmFsIHByb2Nlc3NlZCB0ZWFtIGRhdGEgZm9yICR7dWlkfTpgLCB0ZWFtRGF0YSk7XG4gICAgICAgICAgICB0ZWFtc0FycmF5LnB1c2godGVhbURhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVhbC10aW1lOiBTa2lwcGluZyBpbnZhbGlkIHRlYW0gZGF0YSBmb3IgJHt1aWR9OmAsIGFsbERhdGFbdWlkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnVGVhbXMgZGF0YTonLCB0ZWFtc0FycmF5KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNvcnQgYnkgdGVhbSBudW1iZXIgKGFzY2VuZGluZylcbiAgICAgICAgdGVhbXNBcnJheS5zb3J0KChhLCBiKSA9PiBhLnRlYW1OdW1iZXIgLSBiLnRlYW1OdW1iZXIpO1xuICAgICAgICBcbiAgICAgICAgY2FsbGJhY2sodGVhbXNBcnJheSk7XG4gICAgICB9LFxuICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlYWx0aW1lIERhdGFiYXNlIGxpc3RlbmVyIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgY2FsbGJhY2soW10pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBSZXR1cm4gdW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1Vuc3Vic2NyaWJpbmcgZnJvbSBSZWFsdGltZSBEYXRhYmFzZSBsaXN0ZW5lcicpO1xuICAgICAgb2ZmKHJvb3RSZWYsICd2YWx1ZScsIHVuc3Vic2NyaWJlKTtcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNldHRpbmcgdXAgUmVhbHRpbWUgRGF0YWJhc2UgbGlzdGVuZXI6JywgZXJyb3IpO1xuICAgIHJldHVybiAoKSA9PiB7fTtcbiAgfVxufSJdLCJuYW1lcyI6WyJyZWYiLCJnZXQiLCJ1cGRhdGUiLCJvblZhbHVlIiwib2ZmIiwiZGIiLCJhdXRoIiwic2lnbkluQW5vbnltb3VzbHkiLCJlbnN1cmVBdXRoIiwiY3VycmVudFVzZXIiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsImdldFRlYW1TZXNzaW9uIiwidWlkIiwic2Vzc2lvblJlZiIsInNuYXBzaG90IiwiZXhpc3RzIiwidmFsIiwiZ2V0QWxsVGVhbXMiLCJyb290UmVmIiwiYWxsRGF0YSIsInRlYW1zQXJyYXkiLCJsb2ciLCJ0ZWFtTmFtZSIsInJhd1RlYW1EYXRhIiwidGVhbURhdGEiLCJwaHlzaWNhbFNjb3JlIiwicGh5c2ljYWxTY29yZUNvbW1lbnQiLCJTZXNzaW9uIiwic2Vzc2lvbiIsIk9iamVjdCIsImtleXMiLCJjdXJyZW50Q2x1ZSIsImNsdWVzU29sdmVkIiwidG90YWxDbHVlcyIsInN0YXR1cyIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJ0ZWFtTnVtYmVyIiwidXBkYXRlUGh5c2ljYWxTY29yZSIsImNvbW1lbnQiLCJ0ZWFtUmVmIiwidXBkYXRlRGF0YSIsInVuZGVmaW5lZCIsInN1YnNjcmliZVRvVGVhbXMiLCJjYWxsYmFjayIsInVuc3Vic2NyaWJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/firestore.ts\n"));

/***/ })

});